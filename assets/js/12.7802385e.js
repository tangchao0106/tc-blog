(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{403:function(n,a,t){"use strict";t.r(a);var s=t(2),l=Object(s.a)({},(function(){var n=this._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("h3",{attrs:{id:"call是函数的方法-用在函数上-改变this指向"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#call是函数的方法-用在函数上-改变this指向"}},[this._v("#")]),this._v(" call是函数的方法，用在函数上,改变this指向")]),this._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v('function fn() {\nname:"fn",\n  console.log("call 是函数的方法 改变this指向", this.name);\n}\nlet dog = {\n  name: "dog-name",\n};\nfn.call(dog); // dog-name\n\n\n')])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v('let dog2 = {\n  name: "dog2",\n  say(a, b) {\n    console.log("传参", this.name, a, b);\n  },\n};\n// dog2.say();\n//改变this指向\n// dog2.say.call(dog);\n//传参多个\n// dog2.say.call(dog, "aa", "bb");\n//apply区别通过一个数组的形式入参\n// dog2.say.apply(dog, ["apply1", "apply12"]);\n\n// bind改变this指向，返回的是新函数，不会立即执行;\nlet fun3 = dog2.say.bind(dog, "aa", "bb");\nfun3();\n//传参 分开传参\nlet fun3 = dog2.say.bind(dog);\nfun3("11", "22");\n')])])])])}),[],!1,null,null,null);a.default=l.exports}}]);